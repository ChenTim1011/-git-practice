### NodeJS 名詞解釋

一直聽到相關的名詞，但不知道是什麼意思

### 1. 單執行緒

**單執行緒是什麼？**  
單執行緒指的是 Node.js 只使用一個執行緒來處理所有 JavaScript 程式的操作。
所有請求都共用這個執行緒，這使得 Node.js 不會為每個請求創建新的執行緒。

**為什麼單執行緒重要？**  
單執行緒設計減少了建立執行緒的資源開銷，並且避免多執行緒中可能發生的同步問題，讓應用程式更容易管理。

**為什麼我要學習單執行緒？**  
理解單執行緒的工作方式可以幫助你設計更高效的應用程式，特別是在 Node.js 中，單執行緒配合事件循環可以支撐大量 I/O 請求。

**何時該使用單執行緒？**  
當處理大量 I/O 請求或事件驅動的應用程式時，單執行緒搭配事件驅動機制非常適合。

**單執行緒是如何運作的？**  
Node.js 使用一個執行緒來處理 JavaScript 代碼，所有操作交由這個執行緒執行。它藉由事件循環與非同步 I/O 的配合來管理多個請求，避免阻塞。

### 2. 非阻塞

**非阻塞是什麼？**  
非阻塞指的是 Node.js 不會因為 I/O 操作（例如讀取檔案）而停下來等待結果，而是繼續處理其他任務。

**為什麼非阻塞重要？**  
非阻塞大大提升了效能，讓應用程式可以同時處理多個請求，而不用因為等待 I/O 結果而被卡住。

**為什麼我要學習非阻塞？**  
非阻塞模式能幫助你設計更快速、反應更迅速的應用程式，特別適合需要大量 I/O 操作的環境。

**何時該使用非阻塞？**  
在需要高效處理 I/O 請求的應用中，例如伺服器端的檔案或網路操作，非阻塞會讓應用程式運行更順暢。

**非阻塞是如何運作的？**  
非阻塞的操作會讓程式在等待 I/O 結果的同時繼續執行其他任務，當 I/O 完成後，程式會透過事件循環呼叫相應的回調函數。

### 3. 非同步 I/O

**非同步 I/O 是什麼？**  
非同步 I/O 指的是 I/O 操作不會佔用主執行緒，系統會在操作完成後執行指定的回調函數，而不是等待操作結束。

**為什麼非同步 I/O 重要？**  
這種方式能避免執行緒被 I/O 操作阻塞，提高整體效能，讓程式可以在等待 I/O 完成時執行其他任務。

**為什麼我要學習非同步 I/O？**  
非同步 I/O 是許多伺服器應用中不可或缺的概念，它能讓應用在高負載下保持流暢運行。

**何時該使用非同步 I/O？**  
當應用程式需要進行頻繁 I/O 操作（例如檔案讀寫或 API 請求）時，非同步 I/O 非常合適。

**非同步 I/O 是如何運作的？**  
非同步 I/O 讓操作執行在主執行緒以外的地方，當操作完成後，事件循環會呼叫預先指定的回調函數來處理結果。

### 4. 事件循環

**事件循環是什麼？**  
事件循環是 Node.js 的核心機制之一，用於監控程序中的事件，並依次處理它們。

**為什麼事件循環重要？**  
事件循環讓 Node.js 能夠非同步處理任務，並支援單執行緒應用程式高效運行，是處理多任務的關鍵。

**為什麼我要學習事件循環？**  
理解事件循環可以幫助你更好地運用 Node.js 的事件驅動模型，並能避免阻塞。

**何時該使用事件循環？**  
事件循環是 Node.js 的核心，任何 Node.js 應用程式都會使用它來處理事件和回調。

**事件循環是如何運作的？**  
事件循環負責監控程序中的所有事件，並依次執行待處理的回調。它在每個事件完成後才移到下一個事件，確保單執行緒環境中有效率的資源管理。

---

### 簡化解釋

- **單執行緒**：Node.js 只有一條執行緒來處理所有操作，簡化了資源管理。
- **非阻塞**：Node.js 不會等 I/O 結果，讓它繼續處理其他工作，運行更流暢。
- **非同步 I/O**：I/O 操作在主執行緒之外進行，不會影響其他操作。
- **事件循環**：監控所有待處理事件，按順序處理它們，保持系統流暢。

---

### 程式碼模板

以下為非同步讀取檔案的範例：

```javascript
const fs = require('fs');

console.log("開始讀取檔案...");

// 第一步：呼叫 fs.readFile，開始非同步 I/O 操作
fs.readFile('sample.txt', 'utf8', (err, data) => {
  if (err) {
    console.error("讀取錯誤：", err);
    return;
  }
  // 第二步：I/O 操作完成，進入回調函數，輸出檔案內容
  console.log("檔案內容：", data);
});

// 第三步：繼續執行其他程式碼，不等待讀取完成
console.log("繼續執行其他程式碼...");
```

**解釋步驟**：

1. `fs.readFile` 發送非同步請求，要求讀取檔案內容。
2. `fs.readFile` 結束後，Node.js 繼續執行其他程式碼，直到讀取完成。
3. 讀取完成後觸發回調函數，事件循環將控制權交給該回調函數，處理檔案內容輸出。

---

### 其他問題

### 1. 如何避免單執行緒中因繁重計算阻塞事件循環？

在單執行緒的環境中，繁重的計算會導致事件循環無法及時處理其他請求。以下是避免阻塞的方法：

- **使用 Web Workers 或子執行緒**：將繁重計算移到工作執行緒中處理，讓主執行緒繼續處理 I/O 和其他非阻塞任務。
  
- **分解計算任務**：將繁重的任務分解成多個小任務，以分批處理。這樣可以讓事件循環有機會在各個小任務之間處理其他請求，減少阻塞的影響。

- **利用 Node.js 的 `cluster` 模組**：對於伺服器應用，可以利用 `cluster` 模組啟動多個 Node.js 進程來處理請求，達到多執行緒效果。

### 2. 非阻塞 I/O 與多執行緒有何區別？

- **非阻塞 I/O**：指的是在進行 I/O 操作時，Node.js 不會等待操作完成，而是繼續處理其他任務。這是通過事件驅動與回調來實現的，而非建立多個執行緒。非阻塞 I/O 使得單執行緒的 Node.js 可以有效處理大量 I/O 請求。

- **多執行緒**：指的是創建多個執行緒，每個執行緒可以同時處理不同的任務。多執行緒適合需要並行處理計算密集型任務的情況，但在管理上較為複雜，需要解決執行緒之間的同步問題。

簡單來說，非阻塞 I/O 主要針對 I/O 密集型應用，而多執行緒適合計算密集型應用。

### 3. 事件循環如何管理大量的請求？

事件循環通過以下方式管理大量請求：

- **事件驅動模型**：每個請求的 I/O 操作都會被添加到事件循環中等待處理，Node.js 不會因為等待 I/O 結果而阻塞，而是繼續處理其他事件。

- **回調函數**：每個 I/O 請求會註冊一個回調函數，事件循環在 I/O 操作完成後自動觸發該回調，處理相應的業務邏輯。

- **分階段處理**：事件循環會依次處理事件佇列中的任務，在完成一個事件後移到下一個。這樣 Node.js 就可以在不新增執行緒的情況下處理大量請求。

### 4. 什麼時候應避免使用非同步 I/O？

在以下情況下，可能不適合使用非同步 I/O：

- **計算密集型任務**：如果應用包含大量計算，非同步 I/O 並不能提高效能，這時候反而應考慮將任務分解或移到工作執行緒。

- **簡單且快速的操作**：對於執行時間非常短、運行極快的操作，使用同步 I/O 可能會更簡潔，且影響不大。例如讀取非常小的文件，或者極短的資料操作。

- **需要依賴順序執行的流程**：非同步 I/O 可能會導致順序執行複雜化，尤其在錯誤處理或依賴執行順序的邏輯上，這時同步操作可能更合適。

