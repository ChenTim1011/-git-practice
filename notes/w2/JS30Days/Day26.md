[Problems](https://leetcode.com/problems/flatten-deeply-nested-array/?envType=study-plan-v2&envId=30-days-of-javascript)

---

## Flatten Deeply Nested Array

這道題目要求我們根據給定的深度 `n`，將多維陣列 `arr` 進行部分或全部的展開（flatten），並返回展開後的陣列。多維陣列是指元素中可能包含其他陣列的結構，展開的意思是將子陣列的元素直接移到父陣列中，以降低陣列的嵌套層次。

### 題目解讀

- **展開條件**：展開操作只會在嵌套深度小於 `n` 的情況下執行。也就是說，當嵌套深度達到 `n` 時，就不會繼續展開。
- **深度**：初始的陣列深度為 0，嵌套一層的子陣列深度為 1，依此類推。
- **展開範圍**：當 `n = 0` 時，不會對陣列進行任何展開；當 `n` 足夠大時，陣列會被完全展開，變成一個扁平的一維陣列。

### 解題思路

我們可以使用一個疊（stack）來完成這項工作。這裡的解法使用迭代來模擬遞迴的展開操作，通過堆疊處理每個元素的展開程度，直到達到 `n` 的深度限制。主要步驟如下：

1. **初始化堆疊**：將 `arr` 中的每個元素（包括初始深度）放入堆疊，這樣我們可以逐步展開處理。
2. **處理堆疊元素**：
   - 取出堆疊的頂部元素 `[item, depth]`，根據其類型與深度進行不同的操作：
     - 如果 `item` 是陣列且 `depth > 0`，則將 `item` 中的每個子元素與 `depth - 1` 一起重新加入堆疊中，以便進一步展開。
     - 如果 `item` 不是陣列，或當前 `depth` 已經為 0，則直接將該 `item` 添加到結果中。
3. **結果反轉**：堆疊的先進後出特性使得我們的結果是逆序的，因此最後需要反轉（`reverse()`）以保證正確的順序。

### 程式碼詳解

以下是 JavaScript 的完整程式碼和詳細註解：

```javascript
/**
 * @param {any[]} arr - 多維陣列
 * @param {number} depth - 展開的最大深度
 * @return {any[]} - 展開後的陣列
 */
var flat = function(arr, depth) {
  // 初始化堆疊，每個元素用 [item, depth] 表示，以確保展開的深度記錄
  const stack = [...arr.map(item => [item, depth])];
  const result = [];

  // 當堆疊中有元素時，不斷取出元素進行展開
  while (stack.length > 0) {
    // 取出堆疊的頂部元素（後進先出）
    const [item, depth] = stack.pop();

    // 判斷 item 是否為陣列以及當前 depth 是否允許展開
    if (Array.isArray(item) && depth > 0) {
      // 如果 item 是陣列且還未達到深度限制，將子元素帶著減少的 depth 放入堆疊
      stack.push(...item.map(subItem => [subItem, depth - 1]));
    } else {
      // 如果 item 不是陣列或深度已達限制，直接將 item 放入結果
      result.push(item);
    }
  }

  // 因為是堆疊的後進先出，需要反轉結果順序以保證正確
  return result.reverse();
};
```

### 測試範例說明

以下是一些測試範例和解釋：

#### 範例 1

```javascript
Input: arr = [1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]], n = 0
Output: [1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]]
```

解釋：當 `n = 0` 時，不進行展開，結果為原陣列。

#### 範例 2

```javascript
Input: arr = [1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]], n = 1
Output: [1, 2, 3, 4, 5, 6, 7, 8, [9, 10, 11], 12, 13, 14, 15]
```

解釋：`n = 1` 時，只有深度為 0 的子陣列被展開，深度為 1 的子陣列 `[9, 10, 11]` 未展開。

#### 範例 3

```javascript
Input: arr = [[1, 2, 3], [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]], n = 2
Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
```

解釋：`n = 2` 時，最大深度為 1 的子陣列會被完全展開，因此所有子陣列都被展開至一維。

### 時間與空間複雜度

- **時間複雜度**：`O(N)`，其中 `N` 是 `arr` 中元素總數。每個元素會被堆疊處理一次。
- **空間複雜度**：`O(N)`，最差情況下所有元素都會加入堆疊和結果陣列中。

### 總結

這段程式碼透過堆疊和深度控制，有效地處理了多層嵌套陣列的展開需求，並且避免了使用內建的 `Array.flat()` 方法，從而靈活控制展開的深度。